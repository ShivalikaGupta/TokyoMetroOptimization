import json
import math
from heapq import heappush, heappop
import time
from collections import defaultdict
from heapq import *
import sys


class PriorityQueue:

    def __init__(self, iterable=[]):
        self.heap = []
        for value in iterable:
            heappush(self.heap, (0, value))

    def add(self, value, priority=0):
        heappush(self.heap, (priority, value))

    def pop(self):
        priority, value = heappop(self.heap)
        return value

    def __len__(self):
        return len(self.heap)


# load in all required JSON files
loc = open("locations.json")
location_data = json.load(loc)
conn = open("connections.json")
connection = json.load(conn)
conn2 = open("connections2.json")
connection_updated = json.load(conn2)
name = open("stations.json", encoding="utf8")
station_data = json.load(name)


def all_locations():
    return location_data


def get_station_name(stationId):
    return station_data["stations"][stationId]["name_en"]


def distance_heuristic(current, goal):
    # get distance from current station to goal station
    x1 = location_data[current]['latitude']
    x2 = location_data[goal]['latitude']
    y1 = location_data[current]['longitude']
    y2 = location_data[goal]['longitude']
    horizontal = (x2-x1)**2
    vertical = (y2-y1)**2
    distance = math.sqrt(horizontal + vertical) * 110.574
    return distance


def transfer_heuristic(current, succ):
    # add positive weight to stops that are on the same line as the current station
    if(current[0] == succ[0]):
        # we would rather travel up to 5 km then switch to a different line
        return 0
    return 5


def stop_heuristic(succ, goal):
    # we calculated 0.91794871794 stops per km on the metro system, so we
    # estimate the future number of stops using this value times the km to the goal state
    return 0.91794871794 * distance_heuristic(succ, goal)


def get_heuristic(distance, transfer, stops, current, succ, goal):
    heur = 0
    value = 0
    if(distance):
        temp = distance_heuristic(current, succ)
        heur += distance_heuristic(succ, goal) + temp
        value += temp
    if(transfer):
        temp = transfer_heuristic(current, succ)
        heur += temp
        value += temp
    if(stops):
        heur += stop_heuristic(succ, goal) + 1
        value += 1
    return heur, value


def get_successor(node, connections):
    successors = connections[node]
    names = []
    for i in successors:
        names.append(i[0])
    return names


def reconstruct_path(came_from, start, end):
    """
    >>> came_from = {'b': 'a', 'c': 'a', 'd': 'c', 'e': 'd', 'f': 'd'}
    >>> reconstruct_path(came_from, 'a', 'e')
    ['a', 'c', 'd', 'e']
    """
    reverse_path = [end]
    while end != start:
        end = came_from[end]
        reverse_path.append(end)
    return list(reversed(reverse_path))


def get_transfers(path):
    transfers = 0
    currline = path[0][0]
    for i in range(1, len(path)):
        if path[i][0] != currline:
            currline = path[i][0]
            transfers += 1
    return transfers


def get_distance(path, connections=connection):
    distance = 0
    for i in range(0, len(path)-1):
        connections = connections[path[i]]
        for j in range(0, len(connections)):
            if connections[j][0] == path[i+1]:
                distance += connections[j][1]
    return distance


def generate_path(start, goal, successor_f, heuristic, distance_h, transfer_h, stops_h, connections=connection):
    # This function returns the path that is generated by A* search from the start
    # station to the goal station using the defined successor function and hueristic
    # function to evaluate each step
    # start: train station to start from
    # goal: train station we are trying to get to
    # successor: how we pick the next stop
    # heuristic: how we evaluate the possible next stops
    # distance_h: True if we are minimizing distance
    # transfer_h: True if we are minimizing transfers
    # stops_h: True if we are minimizing stops
    # connections: which connection file to use (defaults to the original connection file)
    start1 = time.time_ns()
    visited = set()
    history = dict()
    distance = {start: 0}
    frontier = PriorityQueue()
    frontier.add(start)
    while frontier:
        node = frontier.pop()
        if node in visited:
            continue
        if goal == node:
            end1 = time.time_ns()
            print("Time taken: " + str(end1-start1))
            return reconstruct_path(history, start, node)
        visited.add(node)
        for successor in successor_f(node, connections):
            heur, value = heuristic(
                distance_h, transfer_h, stops_h, node, successor, goal)
            frontier.add(successor, priority=distance[node] + heur)
            if (successor not in distance or distance[node] + value < distance[successor]):
                distance[successor] = distance[node] + value
                history[successor] = node
    return None


def calculate(start, goal, distance_h, transfer_h, stops_h):
    temp = generate_path(start, goal, get_successor, get_heuristic,
                         distance_h, transfer_h, stops_h, connection)
    temp2 = generate_path(start, goal, get_successor, get_heuristic,
                          distance_h, transfer_h, stops_h, connection_updated)
    result = {}
    result["path"] = temp
    result["distance"] = get_distance(temp, connection)
    result["transfers"] = get_transfers(temp)
    result["added"] = "No"
    result["percent"] = 0
    result2 = {}
    result2["path"] = temp2
    result2["distance"] = get_distance(temp2, connection_updated)
    result2["transfers"] = get_transfers(temp2)
    result2["added"] = "Yes"
    if result["distance"] > result2["distance"]:
        percent = result["distance"] - result2["distance"] / result["distance"]
        result2["percent"] = percent
        return result2
    return result


def test_algo():
    found = False
    for distance1 in range(0, 2):
        for distance2 in range(0, 2):
            for transfers1 in range(0, 2):
                for transfers2 in range(0, 2):
                    for stops1 in range(0, 2):
                        for stops2 in range(0, 2):
                            if(distance1 <= distance2 and transfers1 <= transfers2 and stops1 <= stops2):
                                allzero = distance1 == transfers1 == stops1 == 0 or distance2 == transfers2 == stops2 == 0
                                if not (distance1 == distance2 and transfers1 == transfers2 and stops1 == stops2) and not allzero:
                                    for station1 in location_data:
                                        for station2 in location_data:
                                            path = generate_path(
                                                station1, station2, get_successor, get_heuristic, distance1, transfers1, stops1)
                                            path2 = generate_path(
                                                station1, station2, get_successor, get_heuristic, distance2, transfers2, stops2)
                                            firstdistance = get_distance(path)
                                            seconddistance = get_distance(
                                                path2)
                                            distsame = (
                                                distance1 == distance2 and firstdistance == seconddistance)
                                            distdiff = (
                                                distance1 != distance2 and firstdistance != seconddistance)
                                            onegreater = (distance1 and (
                                                firstdistance < seconddistance))
                                            onelesser = (distance2 and (
                                                firstdistance > seconddistance))
                                            if distsame or (distdiff and (onegreater or onelesser)):
                                                firsttransfer = get_transfers(
                                                    path)
                                                secondtransfer = get_transfers(
                                                    path2)
                                                transsame = (
                                                    transfers1 == transfers2 and firsttransfer == secondtransfer)
                                                transdiff = (
                                                    transfers1 != transfers2 and firsttransfer != secondtransfer)
                                                trangreater = transfers1 and (
                                                    firsttransfer < secondtransfer)
                                                tranlesser = transfers2 and (
                                                    firsttransfer > secondtransfer)
                                                if transsame or (transdiff and (trangreater or tranlesser)):
                                                    firstlen = len(path)
                                                    secondlen = len(path2)
                                                    stopsame = (
                                                        stops1 == stops2 and firstlen == secondlen)
                                                    stopdiff = (
                                                        stops1 != stops2 and firstlen != secondlen)
                                                    stopgreater = stops1 and (
                                                        firstlen < secondlen)
                                                    stoplesser = stops2 and (
                                                        firstlen > secondlen)
                                                    if stopsame or (stopdiff and (stopgreater or stoplesser)):
                                                        print(
                                                            distance1, transfers1, stops1, distance2, transfers2, stops2, station1, station2)
                                                        print("path1:")
                                                        print("distance:" + str(firstdistance), "transfers:" + str(
                                                            firsttransfer), "stops:" + str(firstlen))
                                                        print("path2:")
                                                        print("distance:" + str(seconddistance), "transfers:" + str(
                                                            secondtransfer), "stops:" + str(secondlen))
                                                        found = True
                                                        break
                                        if(found):
                                            found = False
                                            break


def dijkstra(f, t):
    q, seen, mins = [(0, f, [])], [], {f: 0}
    while q:
        (cost, v1, path) = heappop(q)
        if v1 not in seen:
            seen.append(v1)
            path2 = []
            for i in path:
                path2.append(i)
            path2.append(v1)
            path = path2
            if v1 == t:
                return (cost, path)

            for v2, c in connection_updated[v1]:
                if v2 in seen:
                    continue
                prev = mins.get(v2, None)
                next = cost + c
                if prev is None or next < prev:
                    mins[v2] = next
                    heappush(q, (next, v2, path))
    return float("inf"), None
