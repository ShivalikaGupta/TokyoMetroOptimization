import json
import math
from heapq import heappush, heappop
import time

import sys

class PriorityQueue:
    
    def __init__(self, iterable=[]):
        self.heap = []
        for value in iterable:
            heappush(self.heap, (0, value))
    
    def add(self, value, priority=0):
        heappush(self.heap, (priority, value))
    
    def pop(self):
        priority, value = heappop(self.heap)
        return value
    
    def __len__(self):
        return len(self.heap)

loc = open("locations.json")
location_data = json.load(loc)
succ = open("connections.json")
location_data2 = json.load(succ)
succ2 = open("connections2.json")
location_data3 = json.load(succ2)
name = open("stations.json", encoding="utf8")
station_data = json.load(name)

def all_locations():
    return location_data

def get_station_name(stationId):
    return station_data["stations"][stationId]["name_en"]

#get distance from current station to goal station
def distance_heuristic(current, goal):
    #print("current: " + current + ",  goal:" + goal)
    x1 = location_data[current]['latitude']
    x2 = location_data[goal]['latitude']
    y1 = location_data[current]['longitude']
    y2 = location_data[goal]['longitude']
    horizontal = (x2-x1)**2
    vertical = (y2-y1)**2
    distance = math.sqrt(horizontal + vertical)* 110.574
    return distance

#add positive weight to stops that are on the same line as the current station
def transfer_heuristic(current, succ):
    if(current[0] == succ[0]):
        #we would rather travel up to 2 km then switch to a different line
        return 0
    return 5

def stop_heuristic(succ, goal):
    # we calculated 0.91794871794 stops per km on the metro system, so we 
    # estimate the future number of stops using this value times the km to the goal state
    return 0.91794871794 * distance_heuristic(succ, goal)

def get_heuristic(distance, transfer, stops, current, succ, goal):
    heur = 0
    value = 0
    if(distance):
        heur += distance_heuristic(succ, goal) + get_distance(current, succ)
        value += get_distance(current, succ)
    if(transfer):
        heur += transfer_heuristic(current, succ) 
        value += transfer_heuristic(current, succ) 
    if(stops):
        heur += stop_heuristic(succ, goal) + 1
        value += 1
    return heur, value

def get_successor(node, location_data2):
  successors = location_data2[node]
  names = []
  for i in successors:
    names.append(i[0])
  return names

def reconstruct_path(came_from, start, end):
    """
    >>> came_from = {'b': 'a', 'c': 'a', 'd': 'c', 'e': 'd', 'f': 'd'}
    >>> reconstruct_path(came_from, 'a', 'e')
    ['a', 'c', 'd', 'e']
    """
    reverse_path = [end]
    while end != start:
        end = came_from[end]
        reverse_path.append(end)
    return list(reversed(reverse_path))

def get_transfers(path):
    transfers = 0
    currline = path[0][0]
    for i in range(1, len(path)):
        if path[i][0] != currline:
            currline = path[i][0]
            transfers += 1
    return transfers

def get_distance(path, location_data2):
    distance = 0
    for i in range(0, len(path)-1):
        connections = location_data2[path[i]]
        for j in range(0, len(connections)):
            if connections[j][0] == path[i+1]:
                distance += connections[j][1]
    return distance

#This function returns the path that is generated by A* search from the start 
# station to the goal station using the defined successor function and hueristic 
# function to evaluate each step
# start: train station to start from
# goal: train station we are trying to get to
# successor: how we pick the next stop
# heuristic: how we evaluate the possible next stops
def generate_path(start, goal, successor_f, heuristic, distance_h, transfer_h, stops_h, location_data2 = location_data2):
  visited = set()
  history = dict()
  distance = {start: 0}
  frontier = PriorityQueue()
  frontier.add(start)
  while frontier:
      node = frontier.pop()
    #   print("node = " + node)
      if node in visited:
          continue
      if goal == node:#change this to be if the node == goal station
          return reconstruct_path(history, start, node)
      visited.add(node)
      for successor in successor_f(node, location_data2):
        #   print(successor)
          heur, value = heuristic(distance_h, transfer_h, stops_h, node, successor, goal)
          frontier.add(
              successor,
              priority = distance[node] + heur # we may have to change this as this determines which stop we take next at each step
          )

          if (successor not in distance or distance[node] + value < distance[successor]):
              distance[successor] = distance[node] + value
              history[successor] = node
  return None

def calculate(start, goal, distance_h, transfer_h, stops_h):
    # print("helloooo")
    temp = generate_path(start , goal , get_successor, get_heuristic, distance_h, transfer_h, stops_h, location_data2)
    temp2 = generate_path(start , goal , get_successor, get_heuristic, distance_h, transfer_h, stops_h, location_data3)
    result = {}
    result["path"] = temp
    # print(temp)
    result["distance"] = get_distance(temp, location_data2)
    result["transfers"] = get_transfers(temp)
    result["added"] = "No"
    result["percent"] = 0
    result2 = {}
    result2["path"] = temp2
    result2["distance"] = get_distance(temp2, location_data3)
    result2["transfers"] = get_transfers(temp2)
    result2["added"] = "Yes"
    if result["distance"] > result2["distance"]:
        percent =  result["distance"]- result2["distance"]/ result["distance"]
        result2["percent"] = percent
        return result2 
    return result

<<<<<<< HEAD
def dfs(start, goal):
    stack = [((start, 0), [start])]
    shortest_distance = sys.maxsize
    shortest_path = []
    while stack:
        ((vertex, cost), path) = stack.pop()
        for location in location_data3[vertex]:
            next = location[0]
            dist = location[1]
        #set([succ[0] for succ in location_data3[vertex]]) - set(path):
            if next not in set(path):
                if next == goal:
                    if cost + dist < shortest_distance:
                        shortest_distance = cost +dist 
                        shortest_path = path +[next]
                else:
                    stack.append(((next, cost + dist), path + [next]))
    return shortest_path
    # min = sys.maxsize
    # min_path = []
    # for path in list(result):
    #     curr_distance = get_distance(path, location_data3)
    #     if curr_distance < min:
    #         min = curr_distance
    #         min_path = path 
    # return min_path

start = time.time()
out = dfs("A01", "G12")
end = time.time()

print(out)
print("distance: " + str(get_distance(out, location_data3)))
print("time elapsed: " + str(end - start))


=======
>>>>>>> 3a73f28a67d7106507e1d8d3d0a136411b6d1fd0
def test_algo():
    found = False
    for distance1 in range(0,2):
        for distance2 in range(0,2):
            for transfers1 in range(0,2):
                for transfers2 in range(0,2):
                    for stops1 in range(0,2):
                        for stops2 in range(0,2):
                            if not (distance1 == distance2 and transfers1 == transfers2 and stops1 == stops2) and not (distance1 == transfers1 == stops1 == 0 or distance2 == transfers2 == stops2 == 0 ):
                                for station1 in location_data:
                                    for station2 in location_data:
                                        path = generate_path(station1, station2, get_successor, get_heuristic, distance1, transfers1, stops1)
                                        path2 = generate_path(station1, station2, get_successor, get_heuristic, distance2, transfers2, stops2)
                                        if (distance1 == distance2 and get_distance(path) == get_distance(path2)) or (distance1 != distance2 and get_distance(path) != get_distance(path2)):
                                            if (transfers1 == transfers2 and get_transfers(path) == get_transfers(path2)) or (transfers1 != transfers2 and get_transfers(path) != get_transfers(path2)):
                                                if (stops1 == stops2 and len(path) == len(path2)) or (stops1 != stops2 and len(path) != len(path2)):
                                                    print(distance1, transfers1, stops1, distance2, transfers2, stops2, station1, station2)
                                                    print("path1:")
                                                    print("distance:" + str(get_distance(path)), "transfers:" + str(get_transfers(path)), "stops:" + str(len(path)))
                                                    print("path2:")
                                                    print("distance:" + str(get_distance(path2)),"transfers:" +  str(get_transfers(path2)), "stops:" + str(len(path2)))
                                                    found = True
                                                    break
                                    if(found):
                                        found = False
                                        break
